{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier-Oblique;\f1\fmodern\fcharset0 Courier;\f2\fmodern\fcharset0 Courier-Bold;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue0;\red121\green131\blue149;
\red202\green202\blue202;\red252\green73\blue92;\red83\green166\blue251;\red212\green212\blue212;\red167\green197\blue152;
}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\csgray\c0\c0;\cssrgb\c54902\c58824\c65098;
\cssrgb\c83137\c83137\c83137;\cssrgb\c100000\c38824\c43529;\cssrgb\c38824\c71765\c98824;\cssrgb\c86275\c86275\c86275;\cssrgb\c70980\c80784\c65882;
}
\margl1440\margr1440\vieww16300\viewh14460\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\i\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 /*
\f1\i0 \strokec5 \

\f0\i \strokec4  * Complete the 'numberOfAlerts' function below.
\f1\i0 \strokec5 \

\f0\i \strokec4  *
\f1\i0 \strokec5 \

\f0\i \strokec4  * The function is expected to return an INTEGER.
\f1\i0 \strokec5 \

\f0\i \strokec4  * The function accepts following parameters:
\f1\i0 \strokec5 \

\f0\i \strokec4  *  1. INTEGER precedingMinutes
\f1\i0 \strokec5 \

\f0\i \strokec4  *  2. INTEGER alertThreshold
\f1\i0 \strokec5 \

\f0\i \strokec4  *  3. INTEGER_ARRAY numCalls
\f1\i0 \strokec5 \

\f0\i \strokec4  */
\f1\i0 \strokec5 \
\

\f0\i \strokec4 // function numberOfAlerts(precedingMinutes, alertThreshold, numCalls) \{
\f1\i0 \strokec5 \

\f0\i \strokec4 //     // sliding window with size precedingMinutes
\f1\i0 \strokec5 \

\f0\i \strokec4 //     //if average exceeds alertThreshold, add to alerts sent
\f1\i0 \strokec5 \

\f0\i \strokec4 //     let r = 0
\f1\i0 \strokec5 \

\f0\i \strokec4 //     let window = []
\f1\i0 \strokec5 \

\f0\i \strokec4 //     let numAlerts = 0
\f1\i0 \strokec5 \
    \

\f0\i \strokec4 //     for (let l = 0; l <= numCalls.length - precedingMinutes; l++) \{
\f1\i0 \strokec5 \

\f0\i \strokec4 //         r = l + precedingMinutes
\f1\i0 \strokec5 \

\f0\i \strokec4 //         window = numCalls.slice(l,r)
\f1\i0 \strokec5 \
        \

\f0\i \strokec4 //         //least efficient method because the window average must be repeatedly calculated
\f1\i0 \strokec5 \

\f0\i \strokec4 //         let average = window.reduce((a, b) => a + b, 0) / window.length
\f1\i0 \strokec5 \
        \

\f0\i \strokec4 //         if (average > alertThreshold) numAlerts++
\f1\i0 \strokec5 \

\f0\i \strokec4 //     \}
\f1\i0 \strokec5 \
    \
    \

\f0\i \strokec4 //     return numAlerts
\f1\i0 \strokec5 \

\f0\i \strokec4 // \}
\f1\i0 \strokec5 \
\
\

\f2\b \strokec6 function
\f1\b0 \strokec5  \strokec7 numberOfAlerts\strokec5  \strokec8 (\strokec7 precedingMinutes\strokec8 ,\strokec5  \strokec7 alertThreshold\strokec8 ,\strokec5  \strokec7 numCalls\strokec8 )\strokec5  \strokec8 \{\strokec5 \
    
\f2\b \strokec6 let
\f1\b0 \strokec5  \strokec7 window\strokec5  \strokec8 =\strokec5  \strokec8 []\strokec5 \
    
\f2\b \strokec6 let
\f1\b0 \strokec5  \strokec7 numAlerts\strokec5  \strokec8 =\strokec5  \strokec9 0\strokec5 \
    
\f2\b \strokec6 let
\f1\b0 \strokec5  \strokec7 sum\strokec5  \strokec8 =\strokec5  \strokec9 0\strokec5 \
    \
    
\f0\i \strokec4 // push initial window in
\f1\i0 \strokec5 \
    
\f2\b \strokec6 for
\f1\b0 \strokec5  \strokec8 (
\f2\b \strokec6 let
\f1\b0 \strokec5  \strokec7 i\strokec5  \strokec8 =\strokec5  \strokec9 0\strokec8 ;\strokec5  \strokec7 i\strokec5  \strokec8 <\strokec5  \strokec7 precedingMinutes\strokec8 ;\strokec5  \strokec7 i\strokec8 ++)\{\strokec5 \
        \strokec7 window\strokec8 .\strokec7 push\strokec8 (\strokec7 numCalls\strokec8 [\strokec7 i\strokec8 ])\strokec5 \
        \strokec7 sum\strokec5  \strokec8 +=\strokec5  \strokec7 numCalls\strokec8 [\strokec7 i\strokec8 ]\strokec5 \
    \strokec8 \}\strokec5 \
    \
    
\f0\i \strokec4 // calculate the average for the intial window
\f1\i0 \strokec5 \
    
\f2\b \strokec6 if
\f1\b0 \strokec5  \strokec8 (\strokec7 sum\strokec8 /\strokec7 precedingMinutes\strokec5  \strokec8 >\strokec5  \strokec7 alertThreshold\strokec8 )\strokec5 \
        \strokec7 numAlerts\strokec8 ++\strokec5 \
    \
    
\f0\i \strokec4 // slide the fixed window
\f1\i0 \strokec5 \
    
\f0\i \strokec4 // shift is not optimal because entire array must be shifted forward
\f1\i0 \strokec5 \
    
\f0\i \strokec4 // better to use a queue or a linkedList structure
\f1\i0 \strokec5 \
    
\f2\b \strokec6 for
\f1\b0 \strokec5  \strokec8 (
\f2\b \strokec6 let
\f1\b0 \strokec5  \strokec7 i\strokec5  \strokec8 =\strokec5  \strokec7 precedingMinutes\strokec8 ;\strokec5  \strokec7 i\strokec8 <\strokec5  \strokec7 numCalls\strokec8 .\strokec7 length\strokec8 ;\strokec5  \strokec7 i\strokec8 ++)\{\strokec5 \
        \strokec7 sum\strokec5  \strokec8 -=\strokec5  \strokec7 window\strokec8 [\strokec9 0\strokec8 ]\strokec5 \
        \strokec7 window\strokec8 .\strokec7 shift\strokec8 ()\strokec5 \
        \strokec7 window\strokec8 .\strokec7 push\strokec8 (\strokec7 numCalls\strokec8 [\strokec7 i\strokec8 ])\strokec5 \
        \strokec7 sum\strokec5  \strokec8 +=\strokec5  \strokec7 numCalls\strokec8 [\strokec7 i\strokec8 ]\strokec5 \
        \
        
\f2\b \strokec6 if
\f1\b0 \strokec5  \strokec8 (\strokec7 sum\strokec8 /\strokec7 precedingMinutes\strokec5  \strokec8 >\strokec5  \strokec7 alertThreshold\strokec8 )\strokec5 \
        \strokec7 numAlerts\strokec8 ++\strokec5 \
    \strokec8 \}\strokec5 \
    \
    
\f2\b \strokec6 return
\f1\b0 \strokec5  \strokec7 numAlerts\strokec5 \
\strokec8 \}\strokec5 \
}